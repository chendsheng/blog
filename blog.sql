/*
 Navicat Premium Data Transfer

 Source Server         : Mysql
 Source Server Type    : MySQL
 Source Server Version : 80022
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80022
 File Encoding         : 65001

 Date: 20/04/2022 06:14:59
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `pic` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `views` int NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `category_id` int NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `title`(`title`) USING BTREE,
  INDEX `c_id`(`category_id`) USING BTREE,
  CONSTRAINT `c_id` FOREIGN KEY (`category_id`) REFERENCES `category` (`id`) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 61 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, '常见算法', '算法简介', '[TOC]\r\n\r\n# 常见算法\r\n\r\n## 1.查找算法\r\n\r\n### 1.1	二分查找法\r\n\r\n#### 1.1.1	递归\r\n\r\n```java\r\npublic static int recursion(int num, int[] arr, int low, int height) {\r\n    if (low > height) {\r\n      return -1;\r\n    }\r\n    int mid = (low + height) / 2;\r\n    if (arr[mid] == num) {\r\n      return mid;\r\n    } else if (arr[mid] > num) {\r\n      return recursion(num, arr, low, mid - 1);\r\n    } else {\r\n      return recursion(num, arr, mid + 1, height);\r\n    }\r\n  }\r\n```\r\n\r\n\r\n\r\n#### 1.1.2    非递归\r\n\r\n```java\r\npublic static int binaray(int num, int[] arr) {\r\n    int low = 0;\r\n    int height = arr.length - 1;\r\n    while (low <= height) {\r\n      int mid = (low + height) / 2;\r\n      if (arr[mid] == num) {\r\n        return mid;\r\n      } else if (arr[mid] > num) {\r\n        height = mid - 1;\r\n      } else {\r\n        low = mid + 1;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n```\r\n\r\n\r\n\r\n## 2.排序算法\r\n\r\n### 2.0 时间复杂度\r\n\r\n![image-20220228215029064](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20220228215029064.png)\r\n\r\n\r\n\r\n### 2.1 冒泡排序(稳定)\r\n\r\n- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\r\n- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\r\n- 针对所有的元素重复以上的步骤，除了最后一个。\r\n- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\r\n\r\n![640](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/640.gif)\r\n\r\n```java\r\n public static int[] bubbleSort(int[] sourceArray) {\r\n    // 如果不希望改变源数组顺序，可拷贝一份\r\n    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\r\n    for (int i = 0; i < arr.length - 1; i++) {\r\n      //设置一个标记，判断数组是否已经是有序的\r\n      boolean flag = true;\r\n      for (int j = 0; j < arr.length - i - 1; j++) {\r\n        if (arr[j] > arr[j + 1]) {\r\n          int temp = arr[j];\r\n          arr[j] = arr[j + 1];\r\n          arr[j + 1] = temp;\r\n\r\n          flag = false;\r\n        }\r\n      }\r\n      ////如果当前循环完成后没有进行交换，则说明数组已经是有序的，可直接退出循环\r\n      if (flag) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return arr;\r\n  }\r\n```\r\n\r\n\r\n\r\n### 2.2 选择排序(不稳定)\r\n\r\n- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\r\n- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\r\n- 重复第二步，直到所有元素均排序完毕。\r\n\r\n![641](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/641.gif)\r\n\r\n\r\n\r\n不稳定例子：5   5    4\r\n\r\n第一次交换第一个5会和4交换 ，导致排序后的第一个5在第二个5之后，之前是第一个5在第二个5之前，顺序变了\r\n\r\n\r\n\r\n```java\r\npublic static int[] selectionSort(int[] sourceArray) {\r\n    int[] arr = Arrays.copyOf(sourceArray, sourceArray.length);\r\n\r\n    for (int i = 0; i < arr.length - 1; i++) {\r\n      int min = i;\r\n      for (int j = i + 1; j < arr.length; j++) {\r\n        //找到最小元素下标\r\n        if (arr[min] > arr[j]) {\r\n          min = j;\r\n        }\r\n      }\r\n\r\n      // 将找到的最小值和i位置所在的值进行交换\r\n      if (min != i) {\r\n        int temp = arr[i];\r\n        arr[i] = arr[min];\r\n        arr[min] = temp;\r\n      }\r\n    }\r\n\r\n    return arr;\r\n  }\r\n```\r\n\r\n\r\n\r\n### 2.3 插入排序(稳定)\r\n\r\n- 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\r\n- 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\r\n\r\n![642](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/642.gif)\r\n\r\n\r\n\r\n```java\r\n public static int[] insertSort(int[] sourceArray){\r\n    int[] arr = Arrays.copyOf(sourceArray,sourceArray.length);\r\n\r\n    // 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的\r\n    for (int i =1;i<arr.length;i++){\r\n\r\n      //记录要插入的数据\r\n      int temp = arr[i];\r\n\r\n      //往左查找比插入值最小的数\r\n      int j = i;\r\n      while (j>0 && temp<arr[j-1]){\r\n        arr[j] = arr[j-1];\r\n        j--;\r\n      }\r\n\r\n      // 存在比其小的数，插入\r\n      if (j!=i){\r\n        arr[j] = temp;\r\n      }\r\n    }\r\n    return arr;\r\n  }\r\n```\r\n\r\n\r\n\r\n### 2.4 快速排序(不稳定)\r\n\r\n- 从数列中挑出一个元素，称为 “基准”（pivot）;\r\n\r\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\r\n\r\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；\r\n\r\n  ![快速排序](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/快速排序.gif)\r\n\r\n  \r\n\r\n  \r\n\r\n```java\r\n public static void quickSort(int[] arr,int left,int right){\r\n    if (left>=right){\r\n      return;\r\n    }\r\n\r\n    int pivot = arr[left];\r\n    int l = left;\r\n    int r = right;\r\n    while (l!=r){\r\n      //先移动右指针，保证，pivot>=arr[r],(2,3,4,5);\r\n\r\n      //当右指针的值大于或等于基准值时，右指针向左移动\r\n      while (arr[r]>=pivot && r>l){\r\n        r--;\r\n      }\r\n      //当左指针指向的值小于或等于基准值时，左指针向右移动\r\n      while (arr[l]<=pivot && l<r){\r\n        l++;\r\n      }\r\n\r\n      //当左右都停止移动时,进行交换左右指针的值\r\n      int temp = arr[l];\r\n      arr[l] =arr[r];\r\n      arr[r] = temp;\r\n    }\r\n\r\n    //当左右指针重合时，与基准值进行交换\r\n    arr[left] = arr[l];\r\n    arr[l] = pivot;\r\n\r\n    quickSort(arr,left,r-1);\r\n    quickSort(arr,l+1,right);\r\n  }\r\n```\r\n\r\n\r\n\r\n### 2.5 归并排序(稳定)\r\n\r\n- 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\r\n- 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\r\n- 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\r\n- 重复步骤 3 直到某一指针达到序列尾；\r\n- 将另一序列剩下的所有元素直接复制到合并序列尾。\r\n\r\n归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案\"修补\"在一起，即分而治之)。\r\n\r\n\r\n\r\n![1024555-20161218163120151-452283750](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/1024555-20161218163120151-452283750.png)\r\n\r\n动画演示：![归并排序动画](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/归并排序动画.gif)\r\n\r\n\r\n\r\n```java\r\npublic static void sort(int[] arr) {\r\n    int[] temp = new int[arr.length];\r\n    sort(arr, 0, arr.length - 1, temp);\r\n  }\r\n\r\n  public static void sort(int[] arr, int left, int right, int[] temp) {\r\n    if (left < right) {\r\n      int mid = left + (right - left) / 2;\r\n      sort(arr, left, mid, temp);\r\n      sort(arr, mid + 1, right, temp);\r\n      merge(arr, left, mid, right, temp);\r\n    }\r\n  }\r\n\r\n  public static void merge(int[] arr, int left, int mid, int right, int[] temp) {\r\n    int l = left, r = mid + 1, index = l;//标记缓存数组起始位置index\r\n    while (l <= mid && right >= r) {\r\n      if (arr[l] > arr[r]) {\r\n        temp[index++] = arr[r++];\r\n      } else {\r\n        temp[index++] = arr[l++];\r\n      }\r\n    }\r\n    while (l > mid && right >= r) {\r\n      temp[index++] = arr[r++];\r\n    }\r\n    while (r > right && l <= mid) {\r\n      temp[index++] = arr[l++];\r\n    }\r\n\r\n    while (left <= right) {\r\n      arr[left] = temp[left++];\r\n    }\r\n\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    int[] arr = {7, 1, 6, 3, 5, 8, 10, 9, 4};\r\n    sort(arr);\r\n    System.out.println(Arrays.toString(arr));\r\n  }\r\n```\r\n\r\n### 2.6 希尔排序\r\n\r\n![b8ea087e1663c4131a00912885cc0ccc](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/b8ea087e1663c4131a00912885cc0ccc.jpg)\r\n\r\n\r\n\r\n```java \r\npublic class ShellSort {\r\n  public static void shellSort(int[] arr) {\r\n    int len = arr.length, gap, i, j;\r\n    for (gap = len >> 1; gap > 0; gap >>= 1) {\r\n      //插入排序\r\n      for (i = gap; i < len; i++) {\r\n        int temp = arr[i];\r\n        for (j = i; j >= gap && temp < arr[j - gap]; j -= gap) {\r\n          arr[j] = arr[j - gap];\r\n        }\r\n        arr[j] = temp;\r\n      }\r\n      System.out.println(\"gap=\"+gap+\"->\"+Arrays.toString(arr));\r\n    }\r\n  }\r\n\r\n  public static void main(String[] args) {\r\n    int[] arr = {7, 1, 6, 3, 5, 8, 10, 9, 4};\r\n    shellSort(arr);\r\n    System.out.println(\"最终结果：\"+Arrays.toString(arr));\r\n  }\r\n}\r\n```\r\n\r\n', '/admin/img/pic/6.jpeg', 4, '2022-04-20 05:11:48', '2022-04-20 05:43:26', 1);
INSERT INTO `article` VALUES (2, 'RabbitMQ', 'rabbitmq简介', '[TOC]\r\n\r\n## 安装\r\n\r\n1. 搜索rabbitMq，我们选择带有“mangement”的版本（**包含web管理页面**）；\r\n2. 拉取镜像\r\n3. 启动容器\r\n\r\n```bash\r\ndocker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 -v /home/dds/rabbitmq:/var/lib/rabbitmq --hostname myRabbit -e RABBITMQ_DEFAULT_VHOST=my_vhost  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=123456 --restart=always (容器id)\r\n```\r\n\r\n\r\n\r\n## 使用\r\n\r\n### 如何防止交换机消息被丢弃\r\n\r\n​		我们知道，生产者会先将消息发送给交换机，但是如果交换机此时没有匹配到相关的[队列](https://so.csdn.net/so/search?q=队列&spm=1001.2101.3001.7020)时，交换机中的消息就会出现丢失的问题。\r\n\r\n那么，如何保证交换机中的消息不丢失呢？\r\n\r\n#### mandatory 参数\r\n\r\n​		当 basicPublish 方法的 mandatory 参数设为 true 时，如果[交换器](https://so.csdn.net/so/search?q=交换器&spm=1001.2101.3001.7020)无法匹配到绑定的队列，那么 RabbitMQ 会调用 Basic.Return 命令将消息返回给生产者。\r\n\r\n​		当 mandatory 参数设置为 false 时，若出现上述情形，则消息直接被丢弃。\r\n\r\n​		那么，当 mandatory 参数设为 true 时，生产者如何获取被 [RabbitMQ](https://so.csdn.net/so/search?q=RabbitMQ&spm=1001.2101.3001.7020) 返回的消息呢？这时，可以调用 channel.addReturnListener 来添加 ReturnListener 监听器实现。\r\n\r\n#### 备份交换机\r\n\r\n​		备份交换机（Alternate Exchange）简称 AE，可以理解为备胎交换机。\r\n\r\n​		生产者发送消息时，如果不设置 mandatory 参数，消息在未被正确路由的情况下会丢失；如果设置 mandatory 参数为 true，又需要添加 ReturnListener 的业务处理逻辑，生产者的代码将变得复杂。\r\n\r\n​		如果既不想复杂化生产者的业务逻辑，又不想消息丢失，那么可以使用备份交换器。这样，它可以将未被路由的消息存储在 RabbitMQ 中，再在必要时去处理这些消息。\r\n\r\n​		在声明交换机（exchangeDeclare 方法）时，添加 alternate-exchange 属性参数来实现。还需要声明该备份交换机，并给其绑定一个新的队列。\r\n\r\n​		其实，备份交换器和普通的交换器没有太大的区别，为了方便使用，建议将 AE 设置为 fanout 类型。\r\n\r\n**注意：** 消息被重新发送给备份交换机的路由键和从生产者发出的路由键是一样的。\r\n\r\n对于备份交换机，需要考虑以下几种特殊情况：\r\n\r\n- 如果设置的 AE 不存在，客户端和 RabbitMQ 服务端都不会出现异常，此时消息会丢失。\r\n- 如果 AE 没有绑定任何队列，客户端和 RabbitMQ 服务端都不会出现异常，此时消息会丢失。\r\n- 如果 AE 没有匹配到队列，客户端和 RabbitMQ 服务端都不会出现异常，此时消息会丢失。\r\n- 如果同时使用了 AE 和 mandatory 参数，那么 mandatory 参数无效。\r\n\r\n\r\n\r\n### 1. work模式\r\n\r\n#### 1.1 生产者\r\n\r\n```java\r\nimport com.rabbitmq.client.Channel;\r\nimport com.rabbitmq.client.Connection;\r\nimport java.io.IOException;\r\nimport java.util.concurrent.TimeoutException;\r\n\r\n//消息发送到队列，消费者未消费是，不会消失\r\n//默认是负载均衡的，即使有一个消费者处理非常慢，也是平均分配的\r\npublic class HelloProvider {\r\n  public static void main(String[] args) throws IOException, TimeoutException {\r\n    Connection connection = RabbitmqUtil.getConnection();\r\n    Channel channel = connection.createChannel();\r\n    channel.queueDeclare(\"hello\",false,false,false,null);\r\n\r\n    for (int i = 0; i < 10; i++) {\r\n      channel.basicPublish(\"\", \"hello\", null, (\"Hello rabbit\" + i).getBytes());\r\n    }\r\n    RabbitmqUtil.close(channel,connection);\r\n    System.out.println(666);\r\n  }\r\n}\r\n```\r\n\r\n#### 1.2 消费者\r\n\r\n```java\r\nimport com.rabbitmq.client.*;;\r\nimport java.io.IOException;\r\n\r\npublic class HelloConsumer {\r\n  public static void main(String[] args) throws IOException {\r\n    Connection connection = RabbitmqUtil.getConnection();\r\n    Channel channel = connection.createChannel();\r\n    channel.basicConsume(\"hello\",true,new DefaultConsumer(channel){\r\n      @Override\r\n      public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n        System.out.println(new String(body));\r\n      }\r\n    });\r\n    /*\r\n    消费端不能立即关闭，消息的获取是异步的，主线程关闭不能回调，若想关闭,可以主线程睡眠一会再关闭\r\n    channel.close();\r\n    connection.close();\r\n    */\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n### 2. 交换机模式\r\n\r\n#### 2.1 生产者\r\n\r\n```java\r\nimport com.rabbitmq.client.Channel;\r\nimport com.rabbitmq.client.Connection;\r\nimport java.io.IOException;\r\n\r\n//消息发送到交换机,交换机将消息发送至已连接该交换机的队列中\r\n//交换机不储存消息，若无队列相连，则消息会丢弃，新连接的队列不能获取之前的消息\r\npublic class FanoutProvider {\r\n  public static void main(String[] args) throws IOException {\r\n    Connection connection = RabbitmqUtil.getConnection();\r\n    Channel channel = connection.createChannel();\r\n    channel.exchangeDeclare(\"settle\",\"fanout\");\r\n    for (int i = 0; i < 20; i++) {\r\n      channel.basicPublish(\"settle\",\"\", null,(\"扇出广播型\"+i).getBytes());\r\n    }\r\n    RabbitmqUtil.close(channel,connection);\r\n  }\r\n}\r\n```\r\n\r\n#### 2.2 消费者\r\n\r\n```java\r\nimport com.rabbitmq.client.*;\r\nimport java.io.IOException;\r\n\r\npublic class FanoutConsumer {\r\n  public static void main(String[] args) throws IOException {\r\n    Connection connection = RabbitmqUtil.getConnection();\r\n    Channel channel = connection.createChannel();\r\n    String queue = channel.queueDeclare(\"hello\", false, false, false, null).getQueue();\r\n    channel.queueBind(queue,\"settle\",\"\");\r\n    channel.basicConsume(queue,true,new DefaultConsumer(channel){\r\n      @Override\r\n      public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\r\n        System.out.println(new String(body));\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n## Springboot整合\r\n\r\n1. maven依赖\r\n\r\n```pom\r\n<dependency>\r\n	<groupId>org.springframework.boot</groupId>\r\n	<artifactId>spring-boot-starter-amqp</artifactId>\r\n</dependency>\r\n```\r\n\r\n2. yaml配置\r\n\r\n```yml\r\nspring:\r\n  rabbitmq:\r\n    host: 192.168.116.128\r\n    port: 5672\r\n    virtual-host: my_vhost\r\n    username: admin\r\n    password: 123456\r\n```\r\n\r\n3. 说明\r\n\r\n```java\r\n/**\r\nBroker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输, \r\nExchange：消息交换机,它指定消息按什么规则,路由到哪个队列。 \r\nQueue:消息的载体,每个消息都会被投到一个或多个队列。 \r\nBinding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来. \r\nRouting Key:路由关键字,exchange根据这个关键字进行消息投递。 \r\nvhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。 \r\nProducer:消息生产者,就是投递消息的程序. \r\nConsumer:消息消费者,就是接受消息的程序. \r\nChannel:消息通道,在客户端的每个连接里,可建立多个channel.\r\n*/\r\n```\r\n\r\n### 1. 第一种hello world模型\r\n\r\n直接将消息发送至队列，一个队列只有一个消费者\r\n\r\n#### 1.1 生产者\r\n\r\n```java\r\nimport org.junit.jupiter.api.Test;\r\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n    @Autowired\r\n    private RabbitTemplate rabbitTemplate;\r\n    \r\n    @Test\r\n    void contextLoads() {\r\n        rabbitTemplate.convertAndSend(\"hello\",\"hello world\"); \r\n    }\r\n\r\n}\r\n```\r\n\r\n#### 1.2 消费者\r\n\r\n```java\r\nimport org.springframework.amqp.rabbit.annotation.Queue;\r\nimport org.springframework.amqp.rabbit.annotation.RabbitHandler;\r\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\n@RabbitListener(queuesToDeclare = @Queue(value = \"hello\"))\r\npublic class HelloCustomer {\r\n    @RabbitHandler\r\n    public void receive1(String message){\r\n        System.out.println(\"message = \" + message);\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n### 2. 第二种work模型\r\n\r\n消息直接发送至队列，有多个消费者，默认公平调度，如果需要实现能者多劳需要外配置\r\n\r\n#### 2.1 生产者\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n\r\n\r\n    @Autowired\r\n    private RabbitTemplate rabbitTemplate;\r\n    @Test\r\n    void contextLoads() {\r\n        for (int i = 0; i < 10; i++) {\r\n            rabbitTemplate.convertAndSend(\"work\",\"hello work!\");              \r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### 2.2 消费者\r\n\r\n```java\r\n@Component\r\npublic class WorkCustomer {           \r\n    @RabbitListener(queuesToDeclare = @Queue(\"work\"))\r\n    public void receive1(String message){\r\n        System.out.println(\"work1 message1 = \" + message);\r\n    }\r\n\r\n\r\n    @RabbitListener(queuesToDeclare = @Queue(\"work\"))\r\n    public void receive2(String message){\r\n        System.out.println(\"work2 message2 = \" + message);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 3. fanout广播模型\r\n\r\n消息发送至交换机，由交换机将消息发送至所有与该交换机绑定的队列(每个队列都拥有所有消息)，再被消费者取出\r\n\r\n若多个消费者消费同一队列，则默认是公平分发\r\n\r\n#### 3.1 生产者\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n    @Autowired\r\n    private RabbitTemplate rabbitTemplate;\r\n    \r\n    @Test\r\n    void contextLoads() {\r\n        rabbitTemplate.convertAndSend(\"logs\",\"\",\"这是日志广播\"); // 参数1为交换机，参数2为路由key，“”表示为任意路由，参数3为消息内容\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### 3.2 消费者\r\n\r\n```java\r\n@Component\r\npublic class WorkCustomer {\r\n    @RabbitListener(bindings = @QueueBinding(\r\n            value = @Queue, // 创建临时队列\r\n            exchange = @Exchange(name = \"logs\", type = \"fanout\")\r\n    ))\r\n    public void receive1(String message) {\r\n        System.out.println(\"message1 = \" + message);\r\n    }\r\n\r\n    @RabbitListener(bindings = @QueueBinding(\r\n            value = @Queue, //创建临时队列\r\n            exchange = @Exchange(name = \"logs\", type = \"fanout\")  //绑定交换机类型\r\n    ))\r\n    public void receive2(String message) {\r\n        System.out.println(\"message2 = \" + message);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 4. Route路由模型\r\n\r\n#### 4.1 生产者\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n    @Autowired\r\n    private RabbitTemplate rabbitTemplate;\r\n    \r\n    @Test\r\n    void contextLoads() {\r\n        rabbitTemplate.convertAndSend(\"directs\",\"error\",\"error 的日志信息\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n#### 4.2 消费者\r\n\r\n```java\r\n@Component\r\npublic class WorkCustomer {\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue, // 创建临时队列\r\n                    key = {\"info\", \"error\"}, // 路由key\r\n                    exchange = @Exchange(type = \"direct\", name = \"directs\")\r\n            )})\r\n    public void receive1(String message) {\r\n        System.out.println(\"message1 = \" + message);\r\n    }\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,\r\n                    key = {\"error\"},\r\n                    exchange = @Exchange(type = \"direct\", name = \"directs\")\r\n            )})\r\n    public void receive2(String message) {\r\n        System.out.println(\"message2 = \" + message);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 5. Topic 订阅模型(动态路由模型)\r\n\r\n#### 5.1 生产者\r\n\r\n```java\r\n@SpringBootTest\r\nclass DemoApplicationTests {\r\n    @Autowired\r\n    private RabbitTemplate rabbitTemplate;\r\n    \r\n    @Test\r\n    void contextLoads() {\r\n        rabbitTemplate.convertAndSend(\"topics\",\"user.save.findAll\",\"user.save.findAll 的消息\");\r\n    }\r\n}\r\n```\r\n\r\n#### 5.2 消费者\r\n\r\n```java\r\n@Component\r\npublic class WorkCustomer {\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,\r\n                    key = {\"user.*\"},\r\n                    exchange = @Exchange(type = \"topic\",name = \"topics\")\r\n            )\r\n    })\r\n    public void receive1(String message){\r\n        System.out.println(\"message1 = \" + message);\r\n    }\r\n\r\n    @RabbitListener(bindings = {\r\n            @QueueBinding(\r\n                    value = @Queue,\r\n                    key = {\"user.#\"},\r\n                    exchange = @Exchange(type = \"topic\",name = \"topics\")\r\n            )\r\n    })\r\n    public void receive2(String message){\r\n        System.out.println(\"message2 = \" + message);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 6. 发送对象\r\n\r\nstudent对象\r\n\r\n```\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\n@Data\r\n@Accessors(chain = true)\r\npublic class Student implements Serializable{\r\n  private int id;\r\n  private String name;\r\n  private int age;\r\n  private String sex;\r\n}\r\n```\r\n\r\nprovider\r\n\r\n```java\r\n@GetMapping(\"pro1\")\r\n  public void provider01(){\r\n    Student student = new Student();\r\n    student.setId(1).setAge(18).setName(\"张三\").setSex(\"男\");\r\n    rabbitTemplate.convertAndSend(\"hello\",\"\",student);\r\n  }\r\n```\r\n\r\nconsumer\r\n\r\n```java\r\n @RabbitListener(bindings = @QueueBinding(\r\n          value = @Queue,\r\n          exchange = @Exchange(name = \"hello\",type = \"fanout\")\r\n  ))\r\n  public void recive1(Student student){\r\n    System.out.println(student);\r\n  }\r\n```\r\n\r\n', '/admin/img/pic/4.jpeg', 2, '2022-04-20 05:15:16', '2022-04-20 05:43:19', 5);
INSERT INTO `article` VALUES (3, 'Mysql', 'mysql基础', '[TOC]\r\n\r\n## 数据类型\r\n\r\n### char\r\n\r\n存储0-255个字符,char(n) 实际占用空间为n\r\n\r\n### varchar\r\n\r\nvarchar(n): 0-255个字符，实际占用空间为n+1\r\n\r\n### int \r\n\r\n长度在有填充的情况下才有效，使总长度为 n，填充零 00001\r\n\r\n默认为有符号  -2147483648~ 2147483648\r\n\r\n### text\r\n\r\n存储的是字节数\r\n\r\n## \r\n\r\n## 表\r\n\r\n### 外键\r\n\r\n```mysql\r\n#创建时\r\nCONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段)\r\n\r\n#添加\r\nALTER TABLE 从表名 ADD CONSTRAINT 外键名 FOREIGN KEY (从表外键字段) REFERENCES 主表 (主键字段);\r\n\r\n#例子\r\nALTER TABLE `test`.`student` \r\nADD CONSTRAINT `f` FOREIGN KEY (`tid`) REFERENCES `test`.`teacher` (`id`);\r\n\r\n#删除外键\r\nalter table 从表名 drop foreign key 外键名；\r\nalter table student drop foreign key fk_tid;\r\n```\r\n\r\n> 1、从表里的外键通常为主表的主键\r\n> 2、从表里外键的数据类型必须与主表中主键的数据类型一致\r\n> 3、主表发生变化时应注意主表与从表的数据一致性问题\r\n\r\n\r\n\r\n### 删除表\r\n\r\n> TRUNCATE 和 DETELE：\r\n>\r\n> 1、DELETE语句后可跟WHERE子句，可通过指定WHERE子句中的条件表达式只删除满足条件的部分记录；但是，TRUNCATE语句只能用于删除表中的所有记录。\r\n>\r\n> 2、使用TRUNCATE语句删除表中的数据后，再次向表中添加记录时自动增加字段的默认初始值重新由1开始；使用DELETE语句删除表中所有记录后，再次向表中添加记录时自动增加字段的值为删除时该字段的最大值加1\r\n>\r\n> 3、DELETE语句是DML语句，TRUNCATE语句通常被认为是DDL语句\r\n\r\n\r\n\r\n## 顺序\r\n\r\n**查询语句的书写顺序和执行顺序**\r\nselect ===> from ===> where ===> group by ===> having ===> order by ===> limit\r\n**查询语句的执行顺序**\r\nfrom ===> where ===> group by ===> having ===> select ===> order by ===> limi\r\n\r\n\r\n\r\n## COUNT(*)\r\n\r\n1、 一般情况下，Select Count (*)和Select Count(1)两着返回结果是一样的\r\n\r\n2、 假如表沒有主键，那么count(1)比count(*)快，\r\n\r\n3、 如果有主键的話，那主键作为count的条件时候count(主键)最快\r\n\r\n4、 如果你的表只有一个字段的话那count(*)就是最快的\r\n\r\n5、count(*) 跟 count(1) 的结果一样，都包括对NULL的统计，而**count(column) 是不包括NULL的统计**\r\n\r\n\r\n\r\n## 索引\r\n\r\n### 索引的类型：\r\n\r\n- UNIQUE(唯一索引)：不可以出现相同的值，可以有NULL值\r\n- INDEX(普通索引)：允许出现相同的索引内容\r\n- PROMARY KEY(主键索引)：不允许出现相同的值\r\n- fulltext index(全文索引)：可以针对值中的某个单词，但效率确实不敢恭维\r\n- 组合索引：实质上是将多个字段建到一个索引里，列值的组合必须唯一\r\n\r\n### 索引操作\r\n\r\n```mysql\r\n#删除索引\r\ndrop  INDEX  index_name on table_name ;\r\n\r\n#添加索引\r\n单独创建索引，如下例：\r\nCREATE INDEX index_name on table_name(column_name1,column_name2) ;\r\n或：\r\nALTER TABLE table_name ADD INDEX index_name (column_name1,column_name2);\r\n\r\n#查看\r\nSHOW INDEX FROM table_name;\r\n\r\n#语句分析\r\nEXPLAIN SELECT * from student WHERE id = 12\r\n```\r\n\r\n\r\n\r\n## exists和in\r\n\r\n#### exists\r\n\r\n**执行原理：**由外到内 ----->  外部数据与内部匹配\r\n对外表做loop循环，每次loop循环再对内表（子查询）进行查询，那么因为对内表的查询使用的索引（内表效率高，故可用大表），而外表有多大都需要遍历，不可避免（尽量用小表），故内表大的使用exists，可加快效率；****\r\n\r\n```mysql\r\nselect from tabA where exists (select from tabB where y>0);\r\n```\r\n\r\n- **执行过程:**\r\n  （1）先将tabA表所有记录取到。\r\n  （2）逐行针对tabA表的记录，去关联tabB表，判断tabB表的子查询是否有返回数据，(5.5之后的版本)\r\n  使用Block Nested Loop(Block 嵌套循环)。\r\n  （3）如果子查询有返回数据，则将tabA当前记录返回到结果集。\r\n  tabA相当于取全表数据遍历，tabB可以使用到索引。\r\n\r\n> EXISTS()查询是将主查询的结果集放到子查询中做验证，根据验证结果是true或false来决定主查询数据结果是否得以保存。\r\n\r\n\r\n\r\n#### in\r\n\r\n**执行原理**：由内到外  ----->  内部数据与外部匹配\r\n是把外表和内表做连接，先查询内表，再把内表结果与外表匹配，对外表使用索引（外表效率高，可用大表），而内表多大都需要查询，不可避免，故外表大的使用in，可加快效率。**\r\n\r\n```mysql\r\nselect * from tabA where tabA.x in (select x from tabB where y>0 );\r\n```\r\n\r\n- **执行过程：**\r\n  （1）执行tabB表的子查询，得到结果集B，可以使用到tabB表的索引y；\r\n  （2）执行tabA表的查询，查询条件是tabA.x在结果集B里面，可以使用到tabA表 的索引x。\r\n\r\n> IN()查询是从缓存中取数据\r\n\r\n\r\n\r\n#### 使用场景\r\n\r\n小表驱动大表原则\r\n\r\n外表大用in\r\n\r\n内表大用exits\r\n\r\n差不多的情况下用in，in是从缓存中取出', '/admin/img/pic/7.jpeg', 2, '2022-04-20 05:17:10', '2022-04-20 05:43:15', 2);
INSERT INTO `article` VALUES (4, 'Redis', 'Redis简介', '[TOC]\r\n\r\n# Redis\r\n\r\n#### 配置与启动\r\n\r\n​	官网 \r\n\r\n```url\r\nhttps://download.redis.io/releases/\r\n```\r\n\r\n​	解压 文件\r\n\r\n```sh\r\ntar xzf redis-x.x.x.tar.gz\r\n```\r\n\r\n1. 将reids目录移动到 /opt,然后进入redis目录进行安装\r\n\r\n```shell\r\nyum install gcc-c++   	使用6.0之前的redis,6.0之后的需要自行下载gcc并安装\r\nmake\r\nmake install\r\n```\r\n\r\n​	安装完成后，安装的默认路径在 /usr/local/bin下\r\n\r\n先将解压包中的redis.conf  复制到 安装目录下，保留源文件，修改被复制过来的配置文件\r\n\r\n限制是否只允许本地访问\r\n\r\ndaemonize yes  允许后台启动\r\n\r\n![image-20220316004433725](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20220316004433725.png)\r\n\r\n1. 通过制定的配置文件启动\r\n\r\n```sh\r\nredis-server  redis.conf\r\n```\r\n\r\n2. 连接redis并测试\r\n\r\n```sh\r\nredis-cli\r\n```\r\n\r\n\r\n\r\n1. 查看redis进程是否开启  ps -aux|grep redis\r\n\r\n2. 关闭并退出\r\n\r\n   ```bash\r\n   shutdow  redis-server   关闭\r\n   ```\r\n\r\n   ```bash\r\n   exit   redis-cli		 退出\r\n   ```\r\n\r\n3. ```shell\r\n   127.0.0.1:6379> select 0  ->选择数据库(总共16个 0~15)\r\n   OK\r\n   127.0.0.1:6379> dbsize    ->查看数据库key数量\r\n   (integer) 3\r\n   ```\r\n\r\n4. 数据库清除操作\r\n\r\n   1. 清空当前数据库 flushdb\r\n   2. 清空所有数据库 flushall\r\n\r\n5. Redis是单线程，基于内存操作，CPU并不是性能瓶颈，内存和网络带宽影响其性能，多线程cpu上下文切换，不利于进行快速内存操作\r\n\r\n#### 五大数据类型\r\n\r\n简单上手\r\n\r\n```shell\r\n127.0.0.1:6379> set name ddsst  #设置key\r\nOK\r\n127.0.0.1:6379> get name   #获取key\r\n\"ddsst\"\r\n127.0.0.1:6379> keys *  #获取所有key\r\n1) \"name\"\r\n2) \"counter:__rand_int__\"\r\n3) \"key:__rand_int__\"\r\n127.0.0.1:6379> exists name #判断是否存在key\r\n(integer) 1  #1(存在) 0(不存在) \r\n127.0.0.1:6379> expire name 5 #设置key失效时间（s）\r\n(integer) 1\r\n127.0.0.1:6379> ttl name  #查看剩余时间\r\n(integer) 3\r\n127.0.0.1:6379> ttl name\r\n(integer) -2  #已失效\r\n127.0.0.1:6379> get name\r\n(nil)\r\n127.0.0.1:6379> \r\n127.0.0.1:6379> type name #查看key类型\r\nstring\r\n```\r\n\r\n##### String\r\n\r\n1. 字符操作\r\n\r\n   ```shell\r\n   127.0.0.1:6379> APPEND name nice #追加字符串，若不存在key，则会新建这个key并赋值\r\n   (integer) 6\r\n   127.0.0.1:6379> get name    \r\n   \"vvnice\" \r\n   127.0.0.1:6379> STRLEN name  #查看key值长度\r\n   (integer) 6\r\n   ```\r\n\r\n\r\n2. 加减操作\r\n\r\n   ```shell\r\n   127.0.0.1:6379> get age\r\n   \"19\"\r\n   127.0.0.1:6379> incr age  #加1\r\n   (integer) 20\r\n   127.0.0.1:6379> decr age #减1\r\n   (integer) 19\r\n   127.0.0.1:6379> incrby age 5 #加5\r\n   (integer) 24\r\n   127.0.0.1:6379> decrby age 6 #减6\r\n   (integer) 18\r\n   ```\r\n\r\n3. range（闭区间 【start end】）\r\n\r\n   1. GETRANGE	\r\n\r\n   ```shell\r\n   127.0.0.1:6379> get name\r\n   \"stlove\"\r\n   127.0.0.1:6379> GETRANGE name 2 5\r\n   \"love\"\r\n   127.0.0.1:6379> GETRANGE name 1 -1\r\n   \"tlove\"\r\n   127.0.0.1:6379> GETRANGE name 0 -1 #全部字符串==get key\r\n   \"stlove\"\r\n   ```\r\n\r\n   2. SETRANGE\r\n\r\n   ```shell\r\n   127.0.0.1:6379> get name\r\n   \"stlove\"\r\n   127.0.0.1:6379> SETRANGE name 1 d  #替换指定位置字符\r\n   (integer) 6\r\n   127.0.0.1:6379> get name\r\n   \"sdlove\"\r\n   ```\r\n\r\n   3. setex(设置值和过期时间)  setnx(当key不在，设置key)\r\n\r\n   ```shell\r\n   127.0.0.1:6379> SETEX wife 10 sexy #set with expire\r\n   OK\r\n   127.0.0.1:6379> get wife\r\n   \"sexy\"\r\n   127.0.0.1:6379> ttl wife\r\n   (integer) -2\r\n   127.0.0.1:6379> get wife\r\n   (nil)\r\n   \r\n   127.0.0.1:6379> SETNX car benz #set if not exists\r\n   (integer) 1 #设置成功\r\n   127.0.0.1:6379> SETNX car benzsdaf\r\n   (integer) 0 #设置失败\r\n   ```\r\n\r\n   4. 批量操作\r\n\r\n   ```shell\r\n   127.0.0.1:6379> mset k1 v1 k2 v2  #设置多个key\r\n   OK\r\n   127.0.0.1:6379> keys *\r\n   1) \"k2\"\r\n   2) \"k1\"\r\n   127.0.0.1:6379> mget k1 k2  #获取多个key\r\n   1) \"v1\"\r\n   2) \"v2\"\r\n   \r\n   127.0.0.1:6379> msetnx k1 v1 k3 v3 #批量设置setnx(有一个存在则全部设置失败)\r\n   (integer) 0\r\n   \r\n   ```\r\n\r\n   5. getset(先get ，再set)\r\n\r\n   ```shell\r\n   127.0.0.1:6379> getset name st  #不存在，返回nil\r\n   (nil)\r\n   127.0.0.1:6379> get name\r\n   \"st\"\r\n   127.0.0.1:6379> getset name dds #存在，获取原来值，设置新值\r\n   \"st\"\r\n   127.0.0.1:6379> get name\r\n   \"dds\"\r\n   ```\r\n\r\n##### List \r\n\r\n> 本质上是一个双向链表\r\n\r\n1. 插入\r\n\r\n   ```shell\r\n   127.0.0.1:6379> lpush list a b c d #左插入 表头\r\n   (integer) 4\r\n   127.0.0.1:6379> keys *\r\n   1) \"list\"\r\n   2) \"name\"\r\n   127.0.0.1:6379> type list\r\n   list\r\n   127.0.0.1:6379> LRANGE list 0 -1 #从左读取\r\n   1) \"d\"\r\n   2) \"c\"\r\n   3) \"b\"\r\n   4) \"a\"\r\n   127.0.0.1:6379> RPUSH list e f #右插入  表尾\r\n   (integer) 6\r\n   127.0.0.1:6379> LRANGE list 0 -1\r\n   1) \"d\"\r\n   2) \"c\"\r\n   3) \"b\"\r\n   4) \"a\"\r\n   5) \"e\"\r\n   6) \"f\"\r\n   ```\r\n\r\n2. 删除\r\n\r\n   ```shell\r\n   127.0.0.1:6379> LPOP list \r\n   \"d\"\r\n   127.0.0.1:6379> RPOP list\r\n   \"f\"\r\n   127.0.0.1:6379> LRANGE list 0 -1\r\n   1) \"c\"\r\n   2) \"b\"\r\n   3) \"a\"\r\n   4) \"e\"\r\n   ```\r\n\r\n3. 索引\r\n\r\n   ```shell\r\n   127.0.0.1:6379> LRANGE list 0 -1\r\n   1) \"c\"\r\n   2) \"b\"\r\n   3) \"a\"\r\n   4) \"e\"\r\n   127.0.0.1:6379> LINDEX list 0\r\n   \"c\"\r\n   127.0.0.1:6379> LINDEX list 6  #超出范围\r\n   (nil)\r\n   127.0.0.1:6379> LLEN list #获取列表长度\r\n   (integer) 4\r\n   \r\n   ####################################################################\r\n   LREM LTRIM\r\n   127.0.0.1:6379> lrange list1 0 -1\r\n   1) \"c\"\r\n   2) \"b\"\r\n   3) \"b\"\r\n   4) \"a\"\r\n   5) \"a\"\r\n   6) \"a\"\r\n   127.0.0.1:6379> LREM list1 2 a # 移除两个a元素\r\n   (integer) 2\r\n   127.0.0.1:6379> lrange list1 0 -1\r\n   1) \"c\"\r\n   2) \"b\"\r\n   3) \"b\"\r\n   4) \"a\"\r\n   127.0.0.1:6379> LTRIM list1 1 2 #截取指定范围的元素\r\n   OK\r\n   127.0.0.1:6379> lrange list1 0 -1 \r\n   1) \"b\"\r\n   2) \"b\"\r\n   \r\n   ##################################################################\r\n   rpoplpush #移除最后一个元素，并将该元素移动到另一个list中\r\n   127.0.0.1:6379> RPOPLPUSH list1 list2\r\n   \"b\"\r\n   127.0.0.1:6379> LRANGE list1 0 -1\r\n   1) \"b\"\r\n   127.0.0.1:6379> LRANGE list2 0 -1\r\n   1) \"b\"\r\n   \r\n   127.0.0.1:6379> LRANGE list1 0 -1\r\n   1) \"b\"\r\n   127.0.0.1:6379> lset list1 0 one  #替换指定位置的元素\r\n   OK\r\n   127.0.0.1:6379> LRANGE list1 0 -1\r\n   1) \"one\"\r\n   127.0.0.1:6379> LRANGE list1 1 f #超出范围\r\n   (error) ERR value is not an integer or out of range\r\n   \r\n   ###################################################################\r\n   #LINSERT指定元素前|后插入新元素\r\n   127.0.0.1:6379> LPUSH list a b c\r\n   (integer) 3\r\n   127.0.0.1:6379> LRANGE list 0 -1\r\n   1) \"c\"\r\n   2) \"b\"\r\n   3) \"a\"\r\n   127.0.0.1:6379> LINSERT list before b ab \r\n   (integer) 4\r\n   127.0.0.1:6379> LINSERT list after c d\r\n   (integer) 5\r\n   127.0.0.1:6379> LRANGE list 0 -1\r\n   1) \"c\"\r\n   2) \"d\"\r\n   3) \"ab\"\r\n   4) \"b\"\r\n   5) \"a\"\r\n   ```\r\n\r\n##### Set\r\n\r\n> 无序  不重复\r\n\r\n```shell\r\nredis 127.0.0.1:6379> SADD runoobkey redis\r\n(integer) 1\r\nredis 127.0.0.1:6379> SADD runoobkey mongodb\r\n(integer) 1\r\nredis 127.0.0.1:6379> SADD runoobkey mysql\r\n(integer) 1\r\nredis 127.0.0.1:6379> SADD runoobkey mysql\r\n(integer) 0\r\nredis 127.0.0.1:6379> SMEMBERS runoobkey\r\n\r\n1) \"mysql\"\r\n2) \"mongodb\"\r\n3) \"redis\"\r\n```\r\n\r\n##### Hash\r\n\r\n> 适合存储对私对象 user (name,age)\r\n\r\n```shell\r\n127.0.0.1:6379>  HMSET runoobkey name \"redis tutorial\" description \"redis basic commands for caching\" likes 20 visitors 23000\r\nOK\r\n127.0.0.1:6379>  HGETALL runoobkey\r\n1) \"name\"\r\n2) \"redis tutorial\"\r\n3) \"description\"\r\n4) \"redis basic commands for caching\"\r\n5) \"likes\"\r\n6) \"20\"\r\n7) \"visitors\"\r\n8) \"23000\"\r\n```\r\n\r\n##### Zset\r\n\r\n```shell\r\nredis 127.0.0.1:6379> ZADD runoobkey 1 redis\r\n(integer) 1\r\nredis 127.0.0.1:6379> ZADD runoobkey 2 mongodb\r\n(integer) 1\r\nredis 127.0.0.1:6379> ZADD runoobkey 3 mysql\r\n(integer) 1\r\nredis 127.0.0.1:6379> ZADD runoobkey 3 mysql\r\n(integer) 0\r\nredis 127.0.0.1:6379> ZADD runoobkey 4 mysql\r\n(integer) 0\r\nredis 127.0.0.1:6379> ZRANGE runoobkey 0 10 WITHSCORES\r\n\r\n1) \"redis\"\r\n2) \"1\"\r\n3) \"mongodb\"\r\n4) \"2\"\r\n5) \"mysql\"\r\n6) \"4\"\r\n```\r\n\r\n\r\n\r\n', '/admin/img/pic/2.jpeg', 4, '2022-04-20 05:18:33', '2022-04-20 05:51:55', 6);
INSERT INTO `article` VALUES (5, 'ElasticSearch语法01', 'es', '[TOC]\r\n\r\n**每个文档的版本号\"_version\" 起始值都为1 每次对当前文档成功操作后都加1**\r\n\r\n**而序列号\"_seq_no\"则可以看做是索引的信息 在第一次为索引插入数据时为0 每对索引内数据操作成功一次加1 并且文档会记录是第几次操作使它成为现在的情况的**\r\n\r\n\r\n\r\n## Restful\r\n\r\n### Get\r\n\r\n```java\r\nlocalhost:9200/_cat/indices?v     //获取所有索引\r\nlocalhost:9200/shopping/_search   //获取指定索引的全部文档信息\r\nlocalhost:9200/shopping/_doc/1001 //获取指定id的文档信息\r\n```\r\n\r\n#### 条件查询\r\n\r\nlocalhost:9200/shopping/_search\r\n\r\n```java\r\n//字段查询\r\n{\r\n    \"query\":{\r\n        \"match\":{\r\n            \"category\":\"小米手机\"\r\n        }\r\n    }\r\n}\r\n\r\n//全部查询\r\n{\r\n    \"query\":{\r\n        \"match_all\":{\r\n        }\r\n    }\r\n}\r\n\r\n//分页查询\r\n{\r\n    \"query\":{\r\n        \"match\":{\r\n            \"category\":\"手机\"\r\n        }\r\n    },\r\n    \"from\":0,\r\n    \"size\":2,\r\n    \"_source\":[\"title\"]   //指定显示的字段\r\n    \"sort\":{			  //排序\r\n        \"price\":{\r\n            \"order\":\"desc\"\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### Post\r\n\r\n```java\r\n//添加文档信息 ，若索引不存在会自动创建索引\r\nlocalhost:9200/shopping/_doc  	   //随机id新增\r\nlocalhost:9200/shopping/_doc/1002  //指定id新增,id已存在则会覆盖内容\r\n//Body\r\n{\r\n    \"title\":\"小米手机1001\",\r\n    \"category\":\"小米11\",\r\n    \"price\":3999\r\n} \r\n\r\nlocalhost:9200/shopping/_update/1001 //指定id局部更新内容(若key存在则覆盖值,不存在则创建新的键值)\r\n{\r\n    \"doc\":{\r\n        \"title\":\"华为手机\"\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### Put\r\n\r\n```java\r\nlocalhost:9200/shopping 		   //创建索引\r\nlocalhost:9200/shopping/_doc/1002  //全量更新id的文档信息\r\n//Body\r\n{\r\n    \"title\":\"小米手机1001\",\r\n    \"category\":\"小米11\",\r\n    \"price\":3999\r\n}\r\n```\r\n\r\n\r\n\r\n### Delete\r\n\r\n```java\r\nhttp://localhost:9200/*			  		//删除所有索引\r\nhttp://localhost:9200/shopping    		//删除指定索引\r\nhttp://localhost:9200/shopping/   		//删除所有索引\r\nhttp://localhost:9200/shopping/_doc/1  	//删除指定id的索引\r\n```\r\n\r\n\r\n\r\n### _seq_no和\\_version\r\n\r\n索引内容操作成功 \\_seq\\_no+1,并且记录当前文档操作成功时的\\_seq\\_no,初始成功为0\r\n\r\n\\_version 文档操作成功,\\_version+1,初始成功为1\r\n\r\n\r\n\r\n每个索引只存在一个_type,默认值为\"\\_doc\",若自定义了\\_type名字,也可以使用\\_doc访问', '/admin/img/pic/2.jpeg', 2, '2022-04-20 05:44:42', '2022-04-20 06:03:11', 4);
INSERT INTO `article` VALUES (7, '初识Docker', 'docker入门', '[TOC]\r\n\r\n### docker基础\r\n\r\n#### 安装与卸载\r\n\r\n##### 1.卸载旧版本\r\n\r\n```shell\r\n#安装前先卸载掉旧版本\r\n sudo yum remove docker \\\r\n                  docker-client \\\r\n                  docker-client-latest \\\r\n                  docker-common \\\r\n                  docker-latest \\\r\n                  docker-latest-logrotate \\\r\n                  docker-logrotate \\\r\n                  docker-engine\r\n```\r\n\r\n##### 2.配置docker yum源\r\n\r\n```shell\r\n#yun-utils提供yum-config-manager\r\n#使用阿里云Docker Yum源\r\nsudo yum install -y yum-utils\r\nsudo yum-config-manager \\\r\n    --add-repo \\\r\n    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\r\n #创建yum缓存增加搜索速度\r\n yum makecache fast\r\n```\r\n\r\n##### 3.安装Docker Engine\r\n\r\n```shell\r\n #1.安装最新版\r\n sudo yum install -y docker-ce docker-ce-cli containerd.io\r\n \r\n #2.指定版本安装\r\n #查看版本\r\n yum list docker-ce --showduplicates | sort -r\r\n #安装\r\n sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\r\n \r\n```\r\n\r\n##### 4.启动Docker\r\n\r\n```shell\r\n#查看版本\r\nsudo docker version\r\n#启动\r\nsudo systemctl start docker\r\n#设置开机启动\r\nsudo systemctl enable docker\r\n#查看docker启动状态\r\nsystemctl status docker\r\n```\r\n\r\n##### 5.配置镜像加速\r\n\r\n```shell\r\nsudo mkdir -p /etc/docker\r\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\r\n{\r\n  \"registry-mirrors\": [\"https://p4fpl3w7.mirror.aliyuncs.com\"]\r\n}\r\nEOF\r\nsudo systemctl daemon-reload\r\nsudo systemctl restart docker\r\n```\r\n\r\n##### 6.运行 hello-world镜像\r\n\r\n```shell\r\nsudo docker run hello-world\r\n```\r\n\r\n#### docker自动启动\r\n\r\n##### 1.docker服务设置自动启动\r\n\r\n> 查看已启动服务\r\n\r\n```shell\r\nsystemctl list-units --type=service\r\n```\r\n\r\n> 查看是否设置开机启动\r\n\r\n```shell\r\nsystemctl list-unit-files | grep enable\r\n```\r\n\r\n> 设置开机启动\r\n\r\n```shell\r\nsystemctl enable docker.service\r\n```\r\n\r\n> 关闭开机启动\r\n\r\n```shell\r\nsystemctl disable docker.service\r\n```\r\n\r\n2.docker容器设置自动启动\r\n\r\n```shell\r\n#启动时加--restart=always\r\ndocker run -tid --name tomcat01 -p 8081:8080 --restart=always tomcat\r\n\r\nFlag	Description\r\nno		不自动重启容器. (默认value)\r\non-failure 	容器发生error而退出(容器退出状态不为0)重启容器\r\nunless-stopped 	在容器已经stop掉或Docker stoped/restarted的时候才重启容器\r\nalways 	在容器已经stop掉或Docker stoped/restarted的时候才重启容器\r\n```\r\n\r\n```shell\r\n#如果以已经运行的项目\r\ndocker update --restart=always tomcat01\r\n```\r\n\r\n\r\n\r\n#### 常用命令\r\n\r\n##### Docker\r\n\r\n```shell\r\n重启docker服务\r\nsystemctl restart docker\r\n\r\n停止docker服务\r\nsystemctl stop docker\r\n\r\n观察镜像\r\ndocker inspect 镜像名\r\ndocker history 镜像名  镜像构建历史\r\n```\r\n\r\n##### docker容器没有vi/vim\r\n\r\n1、键盘输入命令：apt-get install vim，如果出现如下情况，则需进行第二步；\r\n\r\n![image-20210805020615721](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210805020615721.png)\r\n\r\n2、键盘输入命令：apt-get update\r\n\r\n3、等更新完，再输入apt-get install vim，就会安装vim命令了\r\n\r\n在对linux的防火墙进行操作后需重启docker：service docker restart\r\n\r\n##### 容器\r\n\r\n```sh\r\n1.查看正在运行的容器：docker ps\r\n2.查看所有创建的容器：docker ps -a\r\n3.查看所有容器的id：docker ps -aq\r\n4.删除容器：docker rm -f id\r\n5.删除所有容器：docker rm -f $(docker ps -aq)\r\n6.创建容器：docker run image /bin/bash\r\n7.停止容器：docker stop id(有准备停止)  docker kill id(强制停止)\r\n8.启动容器：docker start id\r\n9.进入容器：docker exec -it id(或name) /bin/bash (exit后不会关闭容器) 或 docker attach id\r\n10.退出容器并使容器后台运行：Ctrl + p + q\r\n11.重启容器: docker restart 容器\r\n12.开机自启动 docker update --restart=always 容器ID，或者创建容器时加上参数 --restart=always\r\n```\r\n\r\n修改容器内文件\r\n\r\n```shell\r\n#将容器内文件拷贝出来\r\ndocker cp mycontainer:/opt/testnew/file.txt /opt/test/\r\n\r\n#将宿主机文件拷贝到容器\r\ndocker cp /opt/test/file.txt mycontainer:/opt/testnew/\r\n\r\n需要注意的是，不管容器有没有启动，拷贝命令都会生效\r\n```\r\n\r\n\r\n\r\n##### 注意事项d\r\n\r\n**`docker run`** 启动容器的时候，常需要将其在后台运行，通常我们设置参数 **`-d`** 即可。\r\n\r\n但后台运行，其实是有前提的，如果没有前台进程，那么实际运行完`docker run`命令后，会处于退出状态，即`exited`。\r\n\r\n```shell\r\ndocker run -itd --name my-redis2 redis /bin/bash\r\n# -i 不是必需，加了，容器起来后终端返回容器ID\r\n刚也提到，就是-d运行容器时，需要有前台进程，-t提供一个伪终端，类似前台进程，查看容器运行状态，也可以看到，容器处于up状态。\r\n#/bin/bash的作用是表示载入容器后运行bash ,docker中必须要保持一个进程的运行，要不然整个容器启动后就会马上kill itself\r\n```\r\n\r\n\r\n\r\n##### 镜像\r\n\r\n```shell\r\n查找镜像：docker search\r\n1.拉取镜像：docker pull image:version(不加版本默认为latest)\r\n2.查看镜像：docker images\r\n3.删除镜像：docker rmi imageId\r\n```\r\n\r\n\r\n\r\n##### portainer\r\n\r\nDocker图形化管理工具\r\n\r\n```shell\r\ndocker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer\r\n```\r\n\r\n##### Tomcat\r\n\r\n启动tomcat\r\n\r\n```shell\r\ndocker run -d -it -p 9527:8080 tomcat:9.0\r\n```\r\n\r\n\r\n\r\n##### commit镜像\r\n\r\n```shell\r\ndocker commit -a=\"lovest\" -m=\"full tomcat\" f1bacec2ee5d tomcat01:1.0\r\n```\r\n\r\n##### 保存镜像\r\n\r\n```shell\r\ndocker save -o nginx.tar nginx2:latest\r\n```\r\n\r\n##### 删除旧镜像\r\n\r\n```sh\r\ndocker rmi fff815b9c91f b175e7467d66\r\n```\r\n\r\n##### load新镜像\r\n\r\n```sh\r\ndocker load -i ./nginx.tar\r\n```\r\n\r\n##### 删除压缩包\r\n\r\n```sh\r\nrm -f nginx.tar\r\n```\r\n\r\n#### 容器数据卷\r\n\r\n##### 挂载\r\n\r\n```shell\r\n# -v(挂载) ceshi(主机目录):/home(容器目录)\r\n#容器目录不可以为相对路径\r\n#主机目录如果不存在，则会自动生成\r\n#如果宿主机中存在/test目录，首先删除它\r\n#主/宿目录删除，对应的目录都将删除\r\n#宿主机目录内容会覆盖容器目录内容，映射前先将主机目录内准备好，可以从一个镜像中cp出来\r\n#whereis nginx  查找容器需要的目录\r\ndocker run -it -v ceshi:/home centos /bin/bash  \r\n```\r\n\r\n![image-20210728231023214](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210728231023214.png)\r\n\r\n##### mysql挂载\r\n\r\n```sh\r\n#启动\r\n-d 后台\r\n-p 端口映射\r\n-v 卷挂载\r\n-e 环境设置\r\n--name 容器名字\r\n#先创建一个容器将/etc/mysql/my.cnf复制到宿主机/home/mysql中，删除该容器，再创建下面命令\r\n[root@lovest data]#docker run -d -p 3306:3306 -v /home/mysql/my.cnf:/etc/mysql/my.cnf -v /home/mysql/data:/var/lib/mysql -v /home/mysql/log:/var/log/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql\r\n```\r\n\r\n##### 具名挂载和匿名挂载\r\n\r\n```shell\r\n#具名挂载\r\n-P(大写p是随机端口)\r\n[root@lovest data]#docker -run -P --name nginx01 -v njuming:etc/nginx nginx\r\n\r\n#匿名挂载\r\n[root@lovest data]#docker -run -P --name nginx02 -v etc/nginx nginx\r\n\r\n#查看所有挂载\r\n[root@lovest data]#docker volume ls\r\n```\r\n\r\n##### docker目录\r\n\r\n![image-20210729004914503](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210729004914503.png)\r\n\r\n```shell\r\n-v 容器内路径  #匿名挂咋\r\n-v 卷名：容器内路径 #具名挂载\r\n-v 主目录：容器目录 #指定目录挂载 (目录为绝对路径)\r\n```\r\n\r\n```shell\r\nro 与 rw #对容器进行限制\r\nro read-only #只读   只能从外部修改，容器内只读\r\nrw read-write #可读写(默认值)\r\n\r\n[root@lovest data]#docker -run -P --name nginx01 -v njuming:etc/nginx:rw nginx\r\n```\r\n\r\n##### 容器互联\r\n\r\n>查看docker网络\r\n\r\n```shell\r\n[root@lovest ~]# docker network ls\r\nNETWORK ID     NAME      DRIVER    SCOPE\r\n435c0d457b1e   bridge    bridge    local\r\ndf50a83208a1   host      host      local\r\n39256096a1f2   none      null      local\r\n```\r\n\r\n###### 网络模式\r\n\r\nbridge：桥接docker(默认)\r\n\r\nnone:不配置网络\r\n\r\nhost:和宿主机共享网络\r\n\r\n###### 查看ip地址\r\n\r\n```shell\r\n[root@lovest ~]# ip addr\r\n```\r\n\r\n###### 自定义网络\r\n\r\ndocker： Failed to Setup IP tables: Unable to enable SKIP DNAT rule 错误的的解决办法\r\n\r\n1，原因：在对 linux 的防火墙进行操作之后，需要重启 docker\r\n\r\n2，解决办法：service docker restart\r\n\r\n创建自定义网络\r\n\r\n```shell\r\n[root@lovest ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet01\r\n\r\n[root@lovest ~]# docker run -d -P --name tomcat01 --net mynet01 tomcat\r\n[root@lovest ~]# docker run -d -P --name tomcat02 --net mynet02 tomcat\r\n\r\n[root@lovest ~]# docker exec tomcat01 ping tomcat02\r\n\r\n#查看mynet01\r\n[root@lovest ~]# docker network inspect mynet\r\n```\r\n\r\n###### 网络连通\r\n\r\n```shell\r\n#创建一个新的容器，不指定在mynet01网络上\r\n[root@lovest ~]# docker run -d -P --name tomcatOther01 tomcat\r\n\r\n#打通与自定义网络之间的连接\r\n[root@lovest ~]# docker network connect mynet01 tomcatOther01\r\n#连通之后，将tomcatOther01放在mynet01的网络下(一个容器两个ip)\r\n```\r\n\r\n#### docker日志\r\n\r\n`docker logs --help`先看下官方给的命令说明\r\n\r\n![img](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/2170344-20201027140021570-1769199979.png)\r\n\r\n- --details 显示更多的信息\r\n- -f, --follow 跟踪实时日志\r\n- --since string 显示自某个timestamp之后的日志，或相对时间，如30m（即30分钟）\r\n- --tail string 从日志末尾显示多少行日志， 默认是all\r\n- -t, --timestamps 显示时间戳\r\n- --until string 显示自某个timestamp之前的日志，或相对时间，如30m（即30分钟）\r\n\r\n举例：\r\n\r\n- 跟踪查看日志\r\n  `docker logs -f CONTAINER_ID`\r\n- 查看日志，只显示最后200行\r\n  `docker logs --tail 200 CONTAINER_ID`\r\n- 查看最近30分钟的日志\r\n  `docker logs --since 30m CONTAINER_ID`\r\n- 查看某时间之后的日志\r\n  `dockere logs -t --since \"2020-10-25T14:06:30\" CONTAINER_ID`\r\n- 查看某时间段之间的日志\r\n  `docker logs -t --since \"2020-10-25T14:06:30\" --until \"2020-10-26T14:06:30\" CONTAINER_ID`\r\n\r\n#### 常用容器\r\n\r\n```shell\r\nnetstat -ntulp |grep 80   //查看所有80端口使用情况·\r\n```\r\n\r\n\r\n\r\n##### ElasticSearch\r\n\r\n限制内存使用\r\n\r\n```shell\r\ndocker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" -e ES_JAVA_OPTS=\"-Xms64m -Xmx512m\" elasticsearch\r\n```\r\n\r\n##### zookeeper\r\n\r\n```shell\r\n[root@localhost ~]# docker run --privileged=true -d --name zookeeper -p 2181:2181  zookeeper:latest\r\n```\r\n\r\n##### dubbo\r\n\r\n```shell\r\n#使用--link连接zookeeper  单机模式\r\n#当多个zookeeper时，使用自定义网络关联一起\r\n[root@localhost ~]# docker run -d --name dubbo -P --link zookeeper apache/dubbo-admin\r\n#使用谷歌或Edge浏览器访问，360有问题\r\n```\r\n\r\n![image-20210805004933878](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210805004933878.png)\r\n\r\n\r\n\r\n##### nginx\r\n\r\n```sh\r\n#文件需要先创建好再映射，touch nginx.conf,创建文件\r\n#nginx镜像默认有启动命令不需要再附加命令，不然会覆盖启动的命令，注意不用-it /bin/bash,否则需要在容器里手动启动服务\r\n[root@lovest conf.d]# docker run -d --name nginx_01 -p 9780:80 -v /home/docker/nginx/html:/usr/share/nginx/html -v /home/docker/nginx/nginx.conf:/etc/nginx/nginx.conf -v /home/docker/nginx/conf.d:/etc/nginx/conf.d nginx\r\n```\r\n\r\n##### redis\r\n\r\nRedis可以实现数据的持久化存储，即将数据保存到磁盘上。\r\nRedis的持久化存储提供两种方式：RDB与AOF。RDB是默认配置。AOF需要手动开启。\r\n现在Redis的配置中默认是关闭AOF模式的。\r\n如果要开启AOF模式，修改Redis的配置文件redis.conf。\r\n\r\nappendonly：是否启动aof，默认是no代表不启用，yes代表启用\r\n\r\nappendfilename：aof的文件名，默认是appendonly.aof\r\n\r\nappendfsync：触发的间隔，默认是everysec代表每秒，另外还有always代表有改变都触发，性能最差但数据最安全，no代表让OS自己决定什么时候执行，性能最好但数据不安全\r\n\r\n```shell\r\n#创建容器\r\ndocker run -p 6379:6379 --name redis -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf -v /mydata/redis/data:/data -d redis redis-server /etc/redis/redis.conf --appendonly yes\r\n\r\nredis-server /etc/redis/redis.conf #按照容器内配置文件启动服务\r\n#进入redis容器\r\ndocker exec -it redis redis-cli\r\n或 docker exec -it redis /bin/bash\r\n	redis-cli\r\n```\r\n\r\n', '/admin/img/pic/5.jpeg', 4, '2022-04-20 05:48:17', '2022-04-20 06:09:37', 7);
INSERT INTO `article` VALUES (8, 'Linux命令01', 'linux命令', '[TOC]\r\n\r\n### Linux解压命令\r\n\r\n把常用的tar解压命令总结下，当作备忘：\r\n\r\n#### tar\r\n\r\n-c: 建立压缩档案\r\n-x：解压\r\n-t：查看内容\r\n-r：向压缩归档文件末尾追加文件\r\n-u：更新原压缩包中的文件\r\n\r\n这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。\r\n\r\n-z：有gzip属性的\r\n-j：有bz2属性的\r\n-Z：有compress属性的\r\n-v：显示所有过程\r\n-O：将文件解开到标准输出\r\n\r\n下面的参数-f是必须的\r\n\r\n-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。\r\n\r\n\\# tar -cf all.tar *.jpg\r\n这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。\r\n\r\n\\# tar -rf all.tar *.gif\r\n这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。\r\n\r\n\\# tar -uf all.tar logo.gif\r\n这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。\r\n\r\n\\# tar -tf all.tar\r\n这条命令是列出all.tar包中所有文件，-t是列出文件的意思\r\n\r\n\\# tar -xf all.tar\r\n这条命令是解出all.tar包中所有文件，-x是解开的意思\r\n\r\n\r\n\r\n#### 压缩\r\n\r\n- tar –cvf jpg.tar *.jpg 将目录里所有jpg文件打包成tar.jpg\r\n- tar –czf jpg.tar.gz *.jpg  将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\r\n- tar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\r\n- tar –cZf jpg.tar.Z *.jpg  将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\r\n- rar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linux\r\n- zip jpg.zip *.jpg  zip格式的压缩，需要先下载zip for linux\r\n\r\n#### 解压\r\n\r\n- tar –xvf file.tar 解压 tar包\r\n- tar -xzvf file.tar.gz 解压tar.gz\r\n- tar -xjvf file.tar.bz2  解压 tar.bz2\r\n- tar –xZvf file.tar.Z  解压tar.Z\r\n- unrar e file.rar 解压rar\r\n- unzip file.zip 解压zip\r\n\r\n\r\n\r\n#### 总结\r\n\r\n1. *.tar 用 tar –xvf 解压\r\n2. *.gz 用 gzip -d或者gunzip 解压\r\n3. *.tar.gz和*.tgz 用 tar –xzf 解压\r\n4. *.bz2 用 bzip2 -d或者用bunzip2 解压\r\n5. *.tar.bz2用tar –xjf 解压\r\n6. *.Z 用 uncompress 解压\r\n7. *.tar.Z 用tar –xZf 解压\r\n8. *.rar 用 unrar e解压\r\n9. *.zip 用 unzip 解压\r\n\r\n#### 查看linux的内核版本\r\n\r\n```shell\r\n[root@lovest ~]# arch\r\nx86_64\r\n```\r\n\r\n### \r\n\r\n### 命令\r\n\r\n#### 查找文件\r\n\r\n```shell\r\nfind / -name **\r\n```\r\n\r\n#### 跟踪文件\r\n\r\n```shel\r\ntail -f filename\r\n等同于--follow=descriptor，根据文件描述符进行追踪，当文件改名或被删除，追踪停止\r\n\r\ntail -F filename\r\n等同于--follow=name  --retry，根据文件名进行追踪，并保持重试，即该文件被删除或改名后，如果再次创建相同的文件名，会继续追踪\r\n```\r\n\r\n#### jps命令\r\n\r\n```shell\r\n用来查看本地运行着几个java程序，并显示他们的进程号。使用jps时，不需要传递进程号做为参数。\r\n```\r\n\r\n\r\n\r\n### JDK安装与配置\r\n\r\n#### 卸载JDK\r\n\r\n1、先输入java -version 查看是否安装了jdk\r\n\r\n2、如果安装了，检查下安装的路径 which java（查看JDK的安装路径） \r\n\r\n![img](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/1151633-20190129104204104-278118100.png)\r\n\r\n3、卸载 rm -rf JDK地址（卸载JDK） rm -rf /usr/java/jdk/jdk1.8.0_172/\r\n\r\n4、vim命令编辑文件profile vim /etc/profile\r\n\r\n![img](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/1151633-20190129104319055-116669734.png)\r\n\r\n删除配置的环境变量，至此JDK卸载完毕\r\n\r\n5、检查下自带的jdk\r\n\r\n命令：\r\n\r\nrpm -qa |grep java\r\n\r\nrpm -qa |grep jdk\r\n\r\nrpm -qa |grep gcj\r\n\r\n如果没有输入信息表示没有安装。\r\n\r\n如果有安装,可以使用rpm -qa | grep java | xargs rpm -e --nodeps 批量卸载所有带有Java的文件 这句命令的关键字是java\r\n\r\n#### oracle官网下载\r\n\r\n```shell\r\n jdk-XXXX-linux-x64.tar.gz\r\n```\r\n\r\n解压放在/usr目录下\r\n\r\n```shell\r\nmv jdk-XXXX /usr/\r\n```\r\n\r\n#### 配置java环境变量\r\n\r\n##### 1.vim /etc/profile\r\n\r\n```shell\r\nexport JAVA_HOME=/usr/jdk1.8.0_121\r\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\r\nexport PATH=$PATH:$JAVA_HOME/bin\r\n```\r\n\r\n##### 2.退出vim编辑器，是环境变量立即生效\r\n\r\n```shll\r\n$ source /etc/profile\r\n```\r\n\r\n##### 3.查看jdk版本\r\n\r\n```shell\r\njava -verison\r\n```\r\n\r\n\r\n\r\n### 后台启动\r\n\r\n```shell\r\n#nohup：no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。\r\n#\'>\'将本该打印在终端的信息(正常输出信息 1 或错误信息 2),重定位到指定文件中\r\n[root@lovest dds]# nohup java -jar lovest.jar > log.log &\r\n```\r\n\r\n查看端口号\r\n\r\n```shell\r\nnetstat -tunlp |grep 端口号\r\n```\r\n\r\n\r\n\r\n查看进程\r\n\r\n```shell\r\n#aux 所有进程   |grep 进行筛选\r\nps aux|grep 进程名\r\n```\r\n\r\n杀死进程\r\n\r\n```shell\r\n#正常结束\r\nkill pid \r\n\r\n#强制结束\r\nkill -9 pid\r\n```\r\n\r\n查看空间占用\r\n\r\n```shell\r\n[root@localhost ~]# df -h\r\n```\r\n\r\n![image-20210804035802030](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210804035802030.png)\r\n\r\n### 虚拟机CentOS网络配置\r\n\r\n```shell\r\n[root@localhost ~]# cd /etc/sysconfig/network-scripts\r\n#ifcfg-ensXX的文件\r\n\r\nBOOTPROTO=static\r\nONBOOT=yes\r\nNM_CONTROLLED=no\r\nDNS1=8.8.8.8\r\nDNS2=4.2.2.2\r\nIPADDR=192.168.116.128\r\nGATEWAY=192.168.116.2\r\n\r\n```\r\n\r\nVm虚拟机网络配置\r\n\r\n第一步：配置主机网络\r\n\r\n![image-20210804041347087](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210804041347087.png)\r\n\r\n\r\n\r\n第二部：配置虚拟机网络  NAT模式  \r\n\r\n![image-20210804040703178](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210804040703178.png)\r\n\r\n配置NAT\r\n\r\n![image-20210804040541185](https://cdn.jsdelivr.net/gh/chendsheng/md_pic/img/image-20210804040541185.png)\r\n\r\n第三部：进入虚拟系统，修改网络配置为固定ip,保持网关一致\r\n\r\n', '/admin/img/pic/7.jpeg', 16, '2022-04-20 05:50:27', '2022-04-20 06:09:33', 8);

-- ----------------------------
-- Table structure for article_tag
-- ----------------------------
DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE `article_tag`  (
  `article_id` int NOT NULL,
  `tag_id` int NOT NULL,
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE,
  INDEX `t_id`(`tag_id`) USING BTREE,
  CONSTRAINT `b_id` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `t_id` FOREIGN KEY (`tag_id`) REFERENCES `tag` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of article_tag
-- ----------------------------
INSERT INTO `article_tag` VALUES (1, 1);
INSERT INTO `article_tag` VALUES (1, 2);
INSERT INTO `article_tag` VALUES (2, 3);
INSERT INTO `article_tag` VALUES (2, 4);
INSERT INTO `article_tag` VALUES (3, 5);
INSERT INTO `article_tag` VALUES (3, 6);
INSERT INTO `article_tag` VALUES (4, 7);
INSERT INTO `article_tag` VALUES (4, 8);
INSERT INTO `article_tag` VALUES (5, 9);
INSERT INTO `article_tag` VALUES (7, 12);
INSERT INTO `article_tag` VALUES (7, 13);
INSERT INTO `article_tag` VALUES (8, 14);

-- ----------------------------
-- Table structure for category
-- ----------------------------
DROP TABLE IF EXISTS `category`;
CREATE TABLE `category`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of category
-- ----------------------------
INSERT INTO `category` VALUES (1, '算法', '/admin/img/category/10.png', '2022-04-20 05:09:51', '2022-04-20 05:09:51');
INSERT INTO `category` VALUES (2, 'mysql', '/admin/img/category/13.png', '2022-04-20 05:10:00', '2022-04-20 05:10:00');
INSERT INTO `category` VALUES (3, 'spring', '/admin/img/category/2.png', '2022-04-20 05:10:10', '2022-04-20 05:10:10');
INSERT INTO `category` VALUES (4, '日常笔记', '/admin/img/category/16.png', '2022-04-20 05:10:27', '2022-04-20 05:10:27');
INSERT INTO `category` VALUES (5, '消息队列', '/admin/img/category/4.png', '2022-04-20 05:14:22', '2022-04-20 05:14:22');
INSERT INTO `category` VALUES (6, '缓存', '/admin/img/category/5.png', '2022-04-20 05:18:06', '2022-04-20 05:18:06');
INSERT INTO `category` VALUES (7, '容器化', '/admin/img/category/3.png', '2022-04-20 05:45:49', '2022-04-20 05:45:49');
INSERT INTO `category` VALUES (8, 'Linux', '/admin/img/category/3.png', '2022-04-20 05:49:52', '2022-04-20 05:49:52');

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 81 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES (1, '算法', '2022-04-20 05:11:49', '2022-04-20 05:11:49');
INSERT INTO `tag` VALUES (2, '数据结构', '2022-04-20 05:11:49', '2022-04-20 05:11:49');
INSERT INTO `tag` VALUES (3, '消息队列', '2022-04-20 05:15:16', '2022-04-20 05:15:16');
INSERT INTO `tag` VALUES (4, 'rabbitmq', '2022-04-20 05:15:16', '2022-04-20 05:15:16');
INSERT INTO `tag` VALUES (5, '数据库', '2022-04-20 05:17:10', '2022-04-20 05:17:10');
INSERT INTO `tag` VALUES (6, 'mysql', '2022-04-20 05:17:10', '2022-04-20 05:17:10');
INSERT INTO `tag` VALUES (7, '缓存', '2022-04-20 05:18:33', '2022-04-20 05:18:33');
INSERT INTO `tag` VALUES (8, 'redis', '2022-04-20 05:18:33', '2022-04-20 05:18:33');
INSERT INTO `tag` VALUES (9, 'ElasticSeach', '2022-04-20 05:44:42', '2022-04-20 05:44:42');
INSERT INTO `tag` VALUES (12, 'docker', '2022-04-20 05:48:17', '2022-04-20 05:48:17');
INSERT INTO `tag` VALUES (13, '容器', '2022-04-20 05:48:17', '2022-04-20 05:48:17');
INSERT INTO `tag` VALUES (14, 'linux', '2022-04-20 05:50:27', '2022-04-20 05:50:27');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  `password` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  `role` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `photo` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `create_time` datetime NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` datetime NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('bfba814e58874d9f9bcc2e065bc776e8', 'admin', 'ed877cba81c2188be673a8017a621cc3', 'admin', NULL, '2022-04-14 00:43:17', '2022-04-14 00:43:17');

SET FOREIGN_KEY_CHECKS = 1;
